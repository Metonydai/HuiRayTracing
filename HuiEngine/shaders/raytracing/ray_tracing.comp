#version 450
#extension GL_GOOGLE_include_directive: enable

#include "Ray.comph"
#include "Hittable.comph"
#include "Random.comph"
#include "Material.comph"

layout (local_size_x = 32, local_size_y = 32, local_size_z = 1) in;

layout (push_constant) uniform PushConstants {
    ivec2 screenSize;
    uint hittableCount;
    uint samples;
    uint maxDepth;
} push;


layout (set = 0, binding = 0) uniform UniformBuffer {
    mat4 viewInverse;
    mat4 projInverse;
    float defocusAngle;
    float defocusRadius;
    float focusDist;
} ubo;

layout (set = 0, binding = 1, rgba8) uniform writeonly image2D outputImage;

// Material related buffer
layout (set = 0, binding = 2, std430) readonly buffer MaterialBuffer
{
    Material materials[];
};

Interface
void Deref(out Material mat, Pointer ptr) { mat = materials[ptr]; }

layout (set = 0, binding = 3, std430) readonly buffer MaterialDumpBuffer
{
    vec4 data[];
} materialData;

Interface
void Deref(Material, out vec4 data, Pointer ptr) { data = materialData.data[ptr];}

// Hittable related buffer
layout (set = 0, binding = 4, std430) readonly buffer HittableBuffer
{
    Hittable hittables[];
};

Interface
void Deref(out Hittable hittable, Pointer ptr) { hittable = hittables[ptr]; }

layout (set = 0, binding = 5, std430) readonly buffer HittableDumpBuffer
{
    vec4 data[];
} hittableData;

Interface
void Deref(Hittable hittable, out vec4 data, Pointer ptr) { data = hittableData.data[ptr]; }

vec3 BackgroundColor(Ray r);

vec3 RayColor(const in Ray ray) 
{
    vec3 color = vec3(1.0f);
    vec3 color_from_emission = vec3(0.0f);
    Ray nextRay = ray;
    
    for (int depth = 0; depth < push.maxDepth; depth++)
    {
        HitRecord rec;
        if (HitAny(push.hittableCount, nextRay, 0.001, 100000.0, rec))
        {
            vec3 attenuation;
            Material mat;
            Deref(mat, rec.mat);
            if (mat.type == MaterialEnum.Diffuselight)
            {
                vec4 data;
                Deref(mat, data, mat.ptr);
                color_from_emission += vec3(data);
                return color + color_from_emission;
            }
            else if (Scatter(mat, nextRay, rec, attenuation, nextRay))
                color *= attenuation;
            else return vec3(0);
        }
        else
            return color * BackgroundColor(nextRay);
    }
    return vec3(0);
}

void main() 
{
    Seed(gl_GlobalInvocationID.xy, push.screenSize, push.samples);
	
    vec2 dim = imageSize(outputImage); // 2048 * 2048

    if(gl_GlobalInvocationID.x >= dim.x
        || gl_GlobalInvocationID.y >= dim.y) return;

    int i = int(gl_GlobalInvocationID.x);
    int j = int(gl_GlobalInvocationID.y);

    vec3 finalColor = vec3(0);

    for (int s = 0; s < push.samples; s++)
    {
    
        vec2 pixelCenter = vec2(gl_GlobalInvocationID.xy) + Rand();
	    vec2 inUV = pixelCenter / dim;
        vec2 d = inUV * 2.0 - 1.0; // NDC-coord

        vec4 apertureView = (ubo.defocusAngle <= 0.0) ? 
            vec4(0, 0, 0, 1) : 
            vec4(ubo.defocusRadius * RandDisk(), 0, 1);
     
        vec4 origin    = ubo.viewInverse * apertureView;  // world space
        vec4 target    = ubo.projInverse * vec4(d, 1, 1); // in view space, but the target is at far plane
        //vec4 direction = ubo.viewInverse * vec4(normalize(target.xyz), 0); // direction in world space

        target = target * (-ubo.focusDist) / target.z;  // scale
        target = ubo.viewInverse * vec4(target.xyz, 1); // in world space
        
        vec4 direction = target - origin;
        
        Ray r;
        Init(r, origin.xyz, direction.xyz);
        finalColor += RayColor(r);
    }

    finalColor /= push.samples;

	imageStore(outputImage, ivec2(gl_GlobalInvocationID.xy), vec4(finalColor, 1.0));
}

vec3 BackgroundColor(Ray r)
{
    vec3 unit_direction = normalize(r.direction);
    float a = 0.5 * (unit_direction.y + 1.0);
    return (1.0 - a) * vec3(1.0, 1.0, 1.0) + a * vec3(0.5, 0.7, 1.0);
}


