#version 450
#extension GL_GOOGLE_include_directive: enable

#include "Ray.comph"
#include "Hittable.comph"
#include "Random.comph"

layout (local_size_x = 32, local_size_y = 32, local_size_z = 1) in;

layout(push_constant) uniform PushConstants {
    ivec2 screenSize;
    uint hittableCount;
    uint samples;
    uint maxDepth;
} push;


layout (set = 0, binding = 0) uniform UniformBuffer {
    mat4 viewInverse;
    mat4 projInverse;
} ubo;

layout (set = 0, binding = 1, rgba8) uniform writeonly image2D outputImage;

layout (set = 0, binding = 2, std430) readonly buffer HittableBuffer
{
    Hittable hittables[];
};

Interface
void Deref(out Hittable hittable, Pointer ptr) { hittable = hittables[ptr]; }

layout(set = 0, binding = 3, std430) readonly buffer HittableDumpBuffer
{
    vec4 data[];
} hittableData;

Interface
void Deref(Hittable hittable, out vec4 data, Pointer ptr) { data = hittableData.data[ptr]; }

vec3 BackgroundColor(Ray r);

vec3 RayColor(const in Ray ray) 
{
    HitRecord rec;
    vec3 color = vec3(0.0f);
    Ray nextRay = ray;
    float attenuation = 0.5;
    int bounces = 0;
    
    for (int depth = 0; depth < push.maxDepth; depth++)
    {
        if (HitAny(push.hittableCount, nextRay, 0.001, 100000.0, rec))
        {
            vec3 direction = RandSemiUnitBall(rec.normal);
            nextRay.origin = rec.p;
            nextRay.direction = direction;
            bounces++;
        }
        else
        {
            return pow(attenuation, bounces) * BackgroundColor(nextRay);
        }
    }

    return vec3(0);
}

void main() 
{
    Seed(gl_GlobalInvocationID.xy, push.screenSize, push.samples);
	
    vec2 dim = imageSize(outputImage); // 2048 * 2048

    if(gl_GlobalInvocationID.x >= dim.x
        || gl_GlobalInvocationID.y >= dim.y) return;

    int i = int(gl_GlobalInvocationID.x);
    int j = int(gl_GlobalInvocationID.y);

    vec3 finalColor = vec3(0);

    for (int s = 0; s < push.samples; s++)
    {
        vec2 pixelCenter = vec2(gl_GlobalInvocationID.xy) + Rand();
	    vec2 inUV = pixelCenter / dim;
        vec2 d = inUV * 2.0 - 1.0; // NDC-coord

        vec4 origin    = ubo.viewInverse * vec4(0, 0, 0, 1);
        vec4 target    = ubo.projInverse * vec4(d.x, d.y, 1, 1); // in view space
        vec4 direction = ubo.viewInverse * vec4(normalize(target.xyz), 0); // direction in world space
        
        Ray r;
        Init(r, origin.xyz, direction.xyz);
        finalColor += RayColor(r);
    }

    finalColor /= push.samples;

	imageStore(outputImage, ivec2(gl_GlobalInvocationID.xy), vec4(finalColor, 1.0));
}

vec3 BackgroundColor(Ray r)
{
    vec3 unit_direction = normalize(r.direction);
    float a = 0.5 * (unit_direction.y + 1.0);
    return (1.0 - a) * vec3(1.0, 1.0, 1.0) + a * vec3(0.5, 0.7, 1.0);
}


