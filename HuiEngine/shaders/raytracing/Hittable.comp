#version 450
#extension GL_GOOGLE_include_directive: enable
#extension GL_EXT_debug_printf : enable
#include "Hittable.comph"

bool HitAny(uint count, Ray r, float t_min, float t_max, out HitRecord rec)
{
    HitRecord temp_rec;
    bool hit_anything = false;
    float closest_so_far = t_max;

    for (int i = 0; i < count; ++i)
    {
        Hittable obj;
        Deref(obj, i);
        if(Hit(obj, r, t_min, closest_so_far, temp_rec))
        {
            hit_anything = true;
            closest_so_far = temp_rec.t;
            temp_rec.mat = obj.mat;
            rec = temp_rec;
        }
    }
    return hit_anything;
}

bool Hit(Hittable self, Ray r, float t_min, float t_max, out HitRecord rec)
{
    switch(self.type)
    {
        case HittableEnum.Sphere:
        {
            Sphere s;
            vec4 data;
            Deref(self, data, self.ptr);
            vec3 center =  data.xyz;
            float radius =  data.w;
            Init(s, center, radius);
            return Hit(s, r, t_min, t_max, rec);
        }
        case HittableEnum.Quad:
        {
            Quad q;
            vec4 data;
            Deref(self, data, self.ptr * 3);
            vec3 Q =  vec3(data);
            
            Deref(self, data, self.ptr * 3 + 1);
            vec3 u =  vec3(data);
            
            Deref(self, data, self.ptr * 3 + 2);
            vec3 v =  vec3(data);

            Init(q, Q, u, v);
            return Hit(q, r, t_min, t_max, rec);
        }
        default:
            return false;
    }
}

// Sphere
void Init(inout Sphere self, vec3 center, float radius)
{
    self.center = center;
    self.radius = radius;
}

bool Hit(Sphere self, Ray r, float t_min, float t_max, out HitRecord rec)
{
    vec3 oc = r.origin - self.center;
    float a = dot(r.direction,r.direction);
    float half_b = dot(oc, r.direction);
    float c = dot(oc,oc) - self.radius * self.radius;

    float discriminant = half_b * half_b - a * c;
    if (discriminant < 0) return false;
    float sqrtd = sqrt(discriminant);

    // Find the nearest root that lies in the acceptable range.
    float root = (-half_b - sqrtd) / a;
    if (root < t_min || t_max < root) {
        root = (-half_b + sqrtd) / a;
        if (root < t_min || t_max < root)
            return false;
    }
    
    rec.t = root;
    rec.p = At(r,rec.t);
    vec3 outwardNormal = (rec.p - self.center) / self.radius;
    SetFaceNormal(rec, r, outwardNormal);
    return true;
}

// Quad
void Init(inout Quad self, vec3 Q, vec3 u, vec3 v)
{
    self.Q = Q;
    self.u = u;
    self.v = v;
}

bool Hit(Quad self, Ray r, float t_min, float t_max, out HitRecord rec)
{
    vec3 n = cross(self.u, self.v);
    vec3 normal = normalize(n);
    float D = dot(normal, self.Q);

    vec3 w = n / dot(n, n);

    float denom = dot(normal, r.direction);

    // No hit if the ray is parallel to the plane.
    if (abs(denom) < 1e-8)
        return false;

    // Return false if the hit point parameter t is outside the ray interval.
    float t = (D - dot(normal, r.origin)) / denom;
    if (t < t_min || t_max < t)
        return false;

    // Determine if the hit point lies within the planar shape using its plane coordinates.
    vec3 intersection = At(r, t);
    vec3 planar_hitpt_vector = intersection - self.Q;
    float alpha = dot(w, cross(planar_hitpt_vector, self.v));
    float beta  = dot(w, cross(self.u, planar_hitpt_vector));

    if (!IsInterior(alpha, beta))
        return false;

    rec.t = t;
    rec.p = At(r, t);
    SetFaceNormal(rec, r, normal);
    return true;
}

bool IsInterior(float a, float b)
{
    return 0 <= a && a <= 1 && 0 <= b && b <= 1;
}